name: Simple CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: "3.11"
  STACK_NAME: bedrock-backend-stack

jobs:
  # ==================== Test ====================
  test:
    name: Test Application
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov black flake8

      - name: Run linting
        run: |
          echo "Running code formatting check..."
          black --check . || true
          echo "Running flake8..."
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true

      - name: Run tests
        run: |
          pytest --cov=. --cov-report=term || echo "No tests found"

  # ==================== Deploy Infrastructure ====================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check if stack exists
        id: check-stack
        run: |
          echo "ðŸ” Checking if stack exists..."
          
          if aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} 2>/dev/null; then
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --query 'Stacks[0].StackStatus' \
              --output text)
            
            echo "stack_exists=true" >> $GITHUB_OUTPUT
            echo "stack_status=$STACK_STATUS" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Stack exists with status: $STACK_STATUS"
          else
            echo "stack_exists=false" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Stack does not exist"
          fi

      - name: Delete failed stack if needed
        if: steps.check-stack.outputs.stack_exists == 'true'
        run: |
          STACK_STATUS="${{ steps.check-stack.outputs.stack_status }}"
          
          # Only delete if stack is in a failed/rollback state that can't be updated
          if [[ "$STACK_STATUS" == "ROLLBACK_COMPLETE" ]] || [[ "$STACK_STATUS" == *"FAILED"* ]]; then
            echo "ðŸ—‘ï¸ Deleting failed stack: ${{ env.STACK_NAME }}"
            echo "âš ï¸ Stack is in $STACK_STATUS state - deletion required"
            
            aws cloudformation delete-stack --stack-name ${{ env.STACK_NAME }}
            
            echo "â³ Waiting for stack deletion to complete..."
            aws cloudformation wait stack-delete-complete \
              --stack-name ${{ env.STACK_NAME }} || true
            
            echo "âœ… Stack deleted successfully"
            echo "needs_creation=true" >> $GITHUB_OUTPUT
          else
            echo "âœ… Stack exists in $STACK_STATUS state - will update instead of recreate"
            echo "needs_creation=false" >> $GITHUB_OUTPUT
          fi
        id: delete-stack

      - name: Get Default VPC and Subnets
        id: get-vpc
        run: |
          echo "ðŸ” Getting default VPC and subnets..."
          
          # Get default VPC
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text)

          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "âœ… Default VPC: $VPC_ID"

          # Get all subnets in default VPC
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'Subnets[*].SubnetId' \
            --output text | tr '\t' ',')

          echo "subnet_ids=$SUBNET_IDS" >> $GITHUB_OUTPUT
          echo "âœ… Subnets: $SUBNET_IDS"

      - name: Validate CloudFormation template
        run: |
          echo "ðŸ” Validating CloudFormation template..."
          aws cloudformation validate-template \
            --template-body file://cloudformation/infrastructure-default-vpc.yaml
          echo "âœ… Template validation successful"

      - name: Prepare parameters
        id: prepare-params
        run: |
          # Handle AllowedOrigins - ensure it's a string
          ALLOWED_ORIGINS='${{ secrets.ALLOWED_ORIGINS }}'
          if [ -z "$ALLOWED_ORIGINS" ]; then
            ALLOWED_ORIGINS='["*"]'
          fi
          echo "allowed_origins=$ALLOWED_ORIGINS" >> $GITHUB_OUTPUT
          echo "âœ… Allowed Origins: $ALLOWED_ORIGINS"

      - name: Deploy CloudFormation Stack
        run: |
          STACK_EXISTS="${{ steps.check-stack.outputs.stack_exists }}"
          NEEDS_CREATION="${{ steps.delete-stack.outputs.needs_creation }}"
          
          if [[ "$STACK_EXISTS" == "false" ]] || [[ "$NEEDS_CREATION" == "true" ]]; then
            echo "ðŸš€ Creating new CloudFormation stack: ${{ env.STACK_NAME }}"
            
            aws cloudformation create-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --template-body file://cloudformation/infrastructure-default-vpc.yaml \
              --parameters \
                ParameterKey=Environment,ParameterValue=production \
                ParameterKey=InstanceType,ParameterValue=t2.micro \
                ParameterKey=KeyPairName,ParameterValue=${{ secrets.EC2_KEY_PAIR_NAME }} \
                ParameterKey=DatabaseURL,ParameterValue="${{ secrets.DATABASE_URL }}" \
                ParameterKey=AWSAccessKeyId,ParameterValue="${{ secrets.AWS_ACCESS_KEY_ID }}" \
                ParameterKey=AWSSecretAccessKey,ParameterValue="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
                ParameterKey=AllowedOrigins,ParameterValue="${{ steps.prepare-params.outputs.allowed_origins }}" \
                ParameterKey=MinSize,ParameterValue=1 \
                ParameterKey=MaxSize,ParameterValue=4 \
                ParameterKey=DesiredCapacity,ParameterValue=1 \
                ParameterKey=VpcId,ParameterValue=${{ steps.get-vpc.outputs.vpc_id }} \
                ParameterKey=SubnetIds,ParameterValue="${{ steps.get-vpc.outputs.subnet_ids }}" \
              --capabilities CAPABILITY_NAMED_IAM \
              --tags \
                Key=Project,Value=BedrockBackend \
                Key=Environment,Value=production \
                Key=ManagedBy,Value=CloudFormation \
                Key=DeployedBy,Value=GitHubActions
            
            echo "â³ Waiting for stack creation to complete (this may take 5-10 minutes)..."
            aws cloudformation wait stack-create-complete \
              --stack-name ${{ env.STACK_NAME }}
            
            echo "âœ… Stack created successfully"
          else
            echo "ðŸ”„ Updating existing CloudFormation stack: ${{ env.STACK_NAME }}"
            
            aws cloudformation update-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --template-body file://cloudformation/infrastructure-default-vpc.yaml \
              --parameters \
                ParameterKey=Environment,ParameterValue=production \
                ParameterKey=InstanceType,ParameterValue=t2.micro \
                ParameterKey=KeyPairName,ParameterValue=${{ secrets.EC2_KEY_PAIR_NAME }} \
                ParameterKey=DatabaseURL,ParameterValue="${{ secrets.DATABASE_URL }}" \
                ParameterKey=AWSAccessKeyId,ParameterValue="${{ secrets.AWS_ACCESS_KEY_ID }}" \
                ParameterKey=AWSSecretAccessKey,ParameterValue="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
                ParameterKey=AllowedOrigins,ParameterValue="${{ steps.prepare-params.outputs.allowed_origins }}" \
                ParameterKey=MinSize,ParameterValue=1 \
                ParameterKey=MaxSize,ParameterValue=4 \
                ParameterKey=DesiredCapacity,ParameterValue=1 \
                ParameterKey=VpcId,ParameterValue=${{ steps.get-vpc.outputs.vpc_id }} \
                ParameterKey=SubnetIds,ParameterValue="${{ steps.get-vpc.outputs.subnet_ids }}" \
              --capabilities CAPABILITY_NAMED_IAM || echo "No updates to perform"
            
            echo "â³ Waiting for stack update to complete..."
            aws cloudformation wait stack-update-complete \
              --stack-name ${{ env.STACK_NAME }} || echo "Update completed or no changes"
            
            echo "âœ… Stack updated successfully"
          fi

      - name: Get Stack Outputs
        id: stack-outputs
        run: |
          ALB_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerURL`].OutputValue' \
            --output text)
          echo "alb_url=$ALB_URL" >> $GITHUB_OUTPUT
          echo "âœ… Load Balancer URL: $ALB_URL"

    outputs:
      alb_url: ${{ steps.stack-outputs.outputs.alb_url }}

  # ==================== Deploy Application ====================
  deploy-application:
    name: Deploy Application Code
    runs-on: ubuntu-latest
    needs: deploy-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Instance IDs
        id: get-instances
        run: |
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=production-bedrock-instance" \
                      "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text)

          if [ -z "$INSTANCE_IDS" ]; then
            echo "âŒ No running instances found"
            exit 1
          fi

          echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_OUTPUT
          echo "âœ… Found instances: $INSTANCE_IDS"

      - name: Deploy to EC2 instances
        run: |
          INSTANCE_IDS="${{ steps.get-instances.outputs.instance_ids }}"

          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Deploying to instance: $INSTANCE_ID"
            
            # Send deployment script
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=[
                "cd /opt/bedrock-backend",
                "echo \"Backing up current deployment...\"",
                "if [ -d app_backup ]; then rm -rf app_backup; fi",
                "if [ -d app ]; then cp -r app app_backup; fi",
                "echo \"Downloading new code from GitHub...\"",
                "rm -rf app_new",
                "git clone --depth 1 --branch main https://github.com/${{ github.repository }}.git app_new",
                "cd app_new",
                "source /opt/bedrock-backend/venv/bin/activate",
                "pip install -r requirements.txt",
                "cd /opt/bedrock-backend",
                "if [ -d app ]; then rm -rf app; fi",
                "mv app_new app",
                "cd app",
                "cp /opt/bedrock-backend/.env .env",
                "sudo supervisorctl restart bedrock-backend",
                "sleep 5",
                "sudo supervisorctl status bedrock-backend",
                "echo \"âœ… Deployment completed\""
              ]' \
              --output text \
              --query 'Command.CommandId')
            
            echo "Command ID: $COMMAND_ID"
            
            # Wait for command to complete
            for i in {1..30}; do
              STATUS=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'Status' \
                --output text 2>/dev/null || echo "Pending")
              
              echo "Status: $STATUS"
              
              if [ "$STATUS" = "Success" ]; then
                echo "âœ… Deployment successful on $INSTANCE_ID"
                break
              elif [ "$STATUS" = "Failed" ]; then
                echo "âŒ Deployment failed on $INSTANCE_ID"
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --query 'StandardErrorContent' \
                  --output text
                exit 1
              fi
              
              sleep 10
            done
          done

  # ==================== Verify Deployment ====================
  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-application]

    steps:
      - name: Health Check
        run: |
          ALB_URL="${{ needs.deploy-infrastructure.outputs.alb_url }}"

          echo "Waiting for application to be ready..."
          sleep 30

          for i in {1..15}; do
            echo "Attempt $i/15: Testing $ALB_URL/health"
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$ALB_URL/health" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Health check passed!"
              
              # Test root endpoint
              echo "Testing root endpoint..."
              curl -s "$ALB_URL/" | jq '.' || echo "Response received"
              
              echo ""
              echo "ðŸŽ‰ Deployment completed successfully!"
              echo "Application URL: $ALB_URL"
              exit 0
            fi
            
            echo "Health check returned: $HTTP_CODE, retrying..."
            sleep 20
          done

          echo "âŒ Health check failed after 15 attempts"
          exit 1

      - name: Generate deployment summary
        if: always()
        run: |
          ALB_URL="${{ needs.deploy-infrastructure.outputs.alb_url }}"

          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸš€ Deployment Summary

          ### Stack Information
          - **Stack Name:** \`${{ env.STACK_NAME }}\`
          - **Region:** \`${{ env.AWS_REGION }}\`
          - **Environment:** \`production\`

          ### Application URL
          - **Load Balancer URL:** $ALB_URL
          - **Health Check:** $ALB_URL/health

          ### Build Information
          - **Commit:** \`${{ github.sha }}\`
          - **Branch:** \`${{ github.ref_name }}\`
          - **Actor:** @${{ github.actor }}
          - **Repository:** ${{ github.repository }}

          ### Deployment Status
          âœ… Infrastructure provisioned successfully
          âœ… Application code deployed via SSM
          âœ… Health checks passed

          ### Quick Access
          \`\`\`bash
          # Test the API
          curl $ALB_URL/health
          curl $ALB_URL/
          \`\`\`

          ---
          *Deployment completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')*
          EOF

  # ==================== Notification ====================
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, verify]
    if: always()

    steps:
      - name: Deployment Status
        run: |
          ALB_URL="${{ needs.deploy-infrastructure.outputs.alb_url }}"

          if [ "${{ needs.verify.result }}" = "success" ]; then
            echo "âœ… Deployment completed successfully!"
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ðŸŒ Application URL: $ALB_URL"
            echo "â¤ï¸  Health Check: $ALB_URL/health"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          else
            echo "âŒ Deployment failed!"
            exit 1
          fi
