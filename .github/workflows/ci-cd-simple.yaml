name: Simple CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: "3.11"
  STACK_NAME: bedrock-backend-stack

jobs:
  # ==================== Test ====================
  test:
    name: Test Application
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov black flake8

      - name: Run linting
        run: |
          echo "Running code formatting check..."
          black --check . || true
          echo "Running flake8..."
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true

      - name: Run tests
        run: |
          pytest --cov=. --cov-report=term || echo "No tests found"

  # ==================== Deploy Infrastructure ====================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Default VPC and Subnets
        id: get-vpc
        run: |
          # Get default VPC
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text)

          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Default VPC: $VPC_ID"

          # Get all subnets in default VPC
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'Subnets[*].SubnetId' \
            --output text | tr '\t' ',')

          echo "subnet_ids=$SUBNET_IDS" >> $GITHUB_OUTPUT
          echo "‚úÖ Subnets: $SUBNET_IDS"

      - name: Deploy CloudFormation Stack
        run: |
          aws cloudformation deploy \
            --template-file cloudformation/infrastructure-default-vpc.yaml \
            --stack-name ${{ env.STACK_NAME }} \
            --parameter-overrides \
              Environment=production \
              InstanceType=t2.micro \
              KeyPairName=${{ secrets.EC2_KEY_PAIR_NAME }} \
              DatabaseURL="${{ secrets.DATABASE_URL }}" \
              AWSAccessKeyId="${{ secrets.AWS_ACCESS_KEY_ID }}" \
              AWSSecretAccessKey="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
              AllowedOrigins="${{ secrets.ALLOWED_ORIGINS || '[\"*\"]' }}" \
              MinSize=1 \
              MaxSize=4 \
              DesiredCapacity=1 \
              VpcId=${{ steps.get-vpc.outputs.vpc_id }} \
              SubnetIds="${{ steps.get-vpc.outputs.subnet_ids }}" \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset

      - name: Get Stack Outputs
        id: stack-outputs
        run: |
          ALB_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerURL`].OutputValue' \
            --output text)
          echo "alb_url=$ALB_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Load Balancer URL: $ALB_URL"

    outputs:
      alb_url: ${{ steps.stack-outputs.outputs.alb_url }}

  # ==================== Deploy Application ====================
  deploy-application:
    name: Deploy Application Code
    runs-on: ubuntu-latest
    needs: deploy-infrastructure

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Instance IDs
        id: get-instances
        run: |
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=production-bedrock-instance" \
                      "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text)

          if [ -z "$INSTANCE_IDS" ]; then
            echo "‚ùå No running instances found"
            exit 1
          fi

          echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_OUTPUT
          echo "‚úÖ Found instances: $INSTANCE_IDS"

      - name: Create deployment package
        run: |
          echo "Creating deployment archive..."
          tar -czf app.tar.gz \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='.env' \
            --exclude='venv' \
            --exclude='node_modules' \
            --exclude='.pytest_cache' \
            --exclude='cloudformation' \
            --exclude='scripts' \
            --exclude='*.md' \
            .

          # Convert to base64 for SSM transmission
          base64 app.tar.gz > app.tar.gz.b64

          # Split into chunks if needed (SSM has size limits)
          split -b 30000 app.tar.gz.b64 chunk_

          echo "‚úÖ Deployment package created"
          ls -lh app.tar.gz

      - name: Deploy to EC2 instances
        run: |
          INSTANCE_IDS="${{ steps.get-instances.outputs.instance_ids }}"

          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Deploying to instance: $INSTANCE_ID"
            
            # Send deployment script
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters 'commands=[
                "cd /opt/bedrock-backend",
                "echo \"Backing up current deployment...\"",
                "if [ -d app_backup ]; then rm -rf app_backup; fi",
                "if [ -d app ]; then cp -r app app_backup; fi",
                "echo \"Downloading new code from GitHub...\"",
                "rm -rf app_new",
                "git clone --depth 1 --branch main https://github.com/${{ github.repository }}.git app_new",
                "cd app_new",
                "source /opt/bedrock-backend/venv/bin/activate",
                "pip install -r requirements.txt",
                "cd /opt/bedrock-backend",
                "if [ -d app ]; then rm -rf app; fi",
                "mv app_new app",
                "cd app",
                "cp /opt/bedrock-backend/.env .env",
                "sudo supervisorctl restart bedrock-backend",
                "sleep 5",
                "sudo supervisorctl status bedrock-backend",
                "echo \"‚úÖ Deployment completed\""
              ]' \
              --output text \
              --query 'Command.CommandId')
            
            echo "Command ID: $COMMAND_ID"
            
            # Wait for command to complete
            for i in {1..30}; do
              STATUS=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'Status' \
                --output text 2>/dev/null || echo "Pending")
              
              echo "Status: $STATUS"
              
              if [ "$STATUS" = "Success" ]; then
                echo "‚úÖ Deployment successful on $INSTANCE_ID"
                break
              elif [ "$STATUS" = "Failed" ]; then
                echo "‚ùå Deployment failed on $INSTANCE_ID"
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --query 'StandardErrorContent' \
                  --output text
                exit 1
              fi
              
              sleep 10
            done
          done

  # ==================== Verify Deployment ====================
  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-application]

    steps:
      - name: Health Check
        run: |
          ALB_URL="${{ needs.deploy-infrastructure.outputs.alb_url }}"

          echo "Waiting for application to be ready..."
          sleep 30

          for i in {1..15}; do
            echo "Attempt $i/15: Testing $ALB_URL/health"
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$ALB_URL/health" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check passed!"
              
              # Test root endpoint
              echo "Testing root endpoint..."
              curl -s "$ALB_URL/" | jq '.' || echo "Response received"
              
              echo ""
              echo "üéâ Deployment completed successfully!"
              echo "Application URL: $ALB_URL"
              exit 0
            fi
            
            echo "Health check returned: $HTTP_CODE, retrying..."
            sleep 20
          done

          echo "‚ùå Health check failed after 15 attempts"
          exit 1

  # ==================== Notification ====================
  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [verify]
    if: always()

    steps:
      - name: Deployment Status
        run: |
          if [ "${{ needs.verify.result }}" = "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
          else
            echo "‚ùå Deployment failed!"
            exit 1
          fi
