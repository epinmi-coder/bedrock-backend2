name: Deploy Application Code to EC2

on:
  push:
    branches:
      - main
      - production
    paths-ignore:
      - "cloudformation/**"
      - "**.md"
      - ".github/workflows/deploy-infrastructure.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
          - development
      run_migrations:
        description: "Run database migrations"
        required: false
        type: boolean
        default: true

env:
  AWS_REGION: us-east-1
  STACK_NAME: bedrock-backend-${{ github.event.inputs.environment || 'production' }}

jobs:
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        run: |
          # Run your test suite here
          # For now, just check if modules can be imported
          python -c "import main; print('‚úÖ Main module imports successfully')"
          python -c "from chats.service import ChatService; print('‚úÖ Chat service imports successfully')"
          python -c "from history.service import ChatHistoryService; print('‚úÖ History service imports successfully')"

      - name: Create deployment package
        run: |
          echo "üì¶ Creating deployment package..."

          # Create tarball excluding unnecessary files
          tar -czf bedrock-backend.tar.gz \
            --exclude='venv' \
            --exclude='__pycache__' \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='logs' \
            --exclude='.env' \
            --exclude='*.pyc' \
            --exclude='cloudformation' \
            --exclude='.pytest_cache' \
            --exclude='*.log' \
            .

          ls -lh bedrock-backend.tar.gz

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: bedrock-backend-${{ github.sha }}
          path: bedrock-backend.tar.gz
          retention-days: 7

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: bedrock-backend-${{ github.sha }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 instance IPs
        id: get-instances
        run: |
          echo "üîç Finding EC2 instances..."

          ASG_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`AutoScalingGroupName`].OutputValue' \
            --output text)

          if [ -z "$ASG_NAME" ]; then
            echo "‚ùå Auto Scaling Group not found. Deploy infrastructure first."
            exit 1
          fi

          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names $ASG_NAME \
            --region ${{ env.AWS_REGION }} \
            --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
            --output text)

          if [ -z "$INSTANCE_IDS" ]; then
            echo "‚ùå No running instances found"
            exit 1
          fi

          INSTANCE_IPS=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_IDS \
            --region ${{ env.AWS_REGION }} \
            --query 'Reservations[*].Instances[*].PublicIpAddress' \
            --output text)

          echo "instance_ips=$INSTANCE_IPS" >> $GITHUB_OUTPUT
          echo "instance_count=$(echo $INSTANCE_IPS | wc -w)" >> $GITHUB_OUTPUT

          echo "‚úÖ Found $(echo $INSTANCE_IPS | wc -w) instance(s)"
          echo "   IPs: $INSTANCE_IPS"

      - name: Setup SSH key
        run: |
          echo "üîë Setting up SSH key..."
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_PRIVATE_KEY }}" > ~/.ssh/deploy_key.pem
          chmod 600 ~/.ssh/deploy_key.pem

          # Add SSH config
          cat >> ~/.ssh/config << EOF
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
            ServerAliveInterval 60
            ServerAliveCountMax 3
          EOF

      - name: Deploy to instances
        id: deploy
        run: |
          echo "üöÄ Deploying to ${{ steps.get-instances.outputs.instance_count }} instance(s)..."

          INSTANCE_IPS="${{ steps.get-instances.outputs.instance_ips }}"
          RUN_MIGRATIONS="${{ github.event.inputs.run_migrations || 'true' }}"
          FAILED_INSTANCES=""
          SUCCESS_INSTANCES=""

          for IP in $INSTANCE_IPS; do
            echo ""
            echo "üì¶ Deploying to instance: $IP"
            
            set +e  # Don't exit on error for individual instance failures
            
            # Upload deployment package with retries
            echo "   ‚¨ÜÔ∏è  Uploading code..."
            UPLOAD_RETRIES=3
            UPLOAD_SUCCESS=false
            
            for i in $(seq 1 $UPLOAD_RETRIES); do
              if scp -i ~/.ssh/deploy_key.pem -o ConnectTimeout=30 bedrock-backend.tar.gz ubuntu@$IP:/tmp/; then
                UPLOAD_SUCCESS=true
                break
              else
                echo "   ‚ö†Ô∏è  Upload attempt $i/$UPLOAD_RETRIES failed"
                sleep 5
              fi
            done
            
            if [ "$UPLOAD_SUCCESS" = false ]; then
              echo "   ‚ùå Failed to upload to $IP after $UPLOAD_RETRIES attempts"
              FAILED_INSTANCES="$FAILED_INSTANCES $IP"
              continue
            fi
            
            # Deploy on instance
            echo "   üîß Deploying on instance..."
            ssh -i ~/.ssh/deploy_key.pem -o ConnectTimeout=30 ubuntu@$IP << 'ENDSSH'
              set -e
              
              echo "   üì¶ Stopping application..."
              sudo supervisorctl stop bedrock-backend || true
              
              echo "   üíæ Backing up existing code..."
              if [ -d /opt/bedrock-backend ]; then
                sudo rm -rf /opt/bedrock-backend-backup
                sudo cp -r /opt/bedrock-backend /opt/bedrock-backend-backup
              fi
              
              echo "   üìÇ Extracting new code..."
              cd /opt/bedrock-backend
              sudo tar -xzf /tmp/bedrock-backend.tar.gz
              sudo chown -R ubuntu:ubuntu /opt/bedrock-backend
              
              echo "   üìö Installing dependencies..."
              source venv/bin/activate
              pip install --upgrade pip -q
              pip install -r requirements.txt -q
              
              RUN_MIGRATIONS="${{ github.event.inputs.run_migrations || 'true' }}"
              if [ "$RUN_MIGRATIONS" = "true" ]; then
                echo "   üóÑÔ∏è  Running database migrations..."
                alembic upgrade head || echo "   ‚ö†Ô∏è  Migration failed or no changes"
              fi
              
              echo "   üöÄ Starting application..."
              sudo supervisorctl start bedrock-backend
              
              echo "   ‚è≥ Waiting for application to start..."
              sleep 5
              
              echo "   ‚úÖ Checking application status..."
              sudo supervisorctl status bedrock-backend
              
              echo "   üß™ Testing health endpoint..."
              for i in {1..10}; do
                if curl -f http://localhost:8000/health 2>/dev/null; then
                  echo "   ‚úÖ Health check passed!"
                  break
                fi
                echo "   ‚è≥ Attempt $i/10 - waiting..."
                sleep 3
              done
              
              echo "   üßπ Cleaning up..."
              rm -f /tmp/bedrock-backend.tar.gz
              
              echo "   ‚úÖ Deployment completed on this instance!"
          ENDSSH
            
            SSH_EXIT_CODE=$?
            set -e
            
            if [ $SSH_EXIT_CODE -eq 0 ]; then
              echo "   ‚úÖ Successfully deployed to $IP"
              SUCCESS_INSTANCES="$SUCCESS_INSTANCES $IP"
            else
              echo "   ‚ùå Deployment failed on $IP (exit code: $SSH_EXIT_CODE)"
              FAILED_INSTANCES="$FAILED_INSTANCES $IP"
              
              # Try to rollback on this instance
              echo "   üîÑ Attempting rollback on $IP..."
              ssh -i ~/.ssh/deploy_key.pem ubuntu@$IP << 'ROLLBACK' || true
                if [ -d /opt/bedrock-backend-backup ]; then
                  sudo supervisorctl stop bedrock-backend || true
                  sudo rm -rf /opt/bedrock-backend
                  sudo mv /opt/bedrock-backend-backup /opt/bedrock-backend
                  sudo supervisorctl start bedrock-backend
                  echo "   ‚Ü©Ô∏è  Rolled back to previous version"
                else
                  echo "   ‚ö†Ô∏è  No backup found for rollback"
                fi
          ROLLBACK
            fi
          done

          echo ""
          echo "üìä Deployment Summary:"
          echo "   Successful: $(echo $SUCCESS_INSTANCES | wc -w) instance(s)"
          echo "   Failed: $(echo $FAILED_INSTANCES | wc -w) instance(s)"

          if [ -n "$FAILED_INSTANCES" ]; then
            echo ""
            echo "‚ùå Deployment failed on the following instances:"
            for IP in $FAILED_INSTANCES; do
              echo "   - $IP"
            done
            exit 1
          fi

          echo ""
          echo "‚úÖ All instances deployed successfully!"

      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."

          ALB_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerURL`].OutputValue' \
            --output text)

          echo "Testing load balancer: $ALB_URL"

          # Wait for load balancer to detect healthy targets
          echo "‚è≥ Waiting for load balancer health checks..."
          sleep 30

          # Test health endpoint with retries
          HEALTH_CHECK_SUCCESS=false
          for i in {1..10}; do
            echo "‚è≥ Health check attempt $i/10..."
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $ALB_URL/health 2>/dev/null || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Load balancer health check passed!"
              HEALTH_CHECK_SUCCESS=true
              break
            else
              echo "   HTTP Status: $HTTP_CODE - waiting..."
              sleep 10
            fi
          done

          if [ "$HEALTH_CHECK_SUCCESS" = false ]; then
            echo "‚ùå Health check failed after 10 attempts"
            echo ""
            echo "üîç Troubleshooting information:"
            
            # Check target health
            TG_ARN=$(aws cloudformation describe-stacks \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query 'Stacks[0].Outputs[?OutputKey==`TargetGroupArn`].OutputValue' \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$TG_ARN" ]; then
              echo "Target Group Health:"
              aws elbv2 describe-target-health \
                --target-group-arn $TG_ARN \
                --region ${{ env.AWS_REGION }} \
                --query 'TargetHealthDescriptions[*].[Target.Id,TargetHealth.State,TargetHealth.Reason]' \
                --output table || true
            fi
            
            exit 1
          fi

      - name: Create deployment summary
        if: always()
        run: |
          ALB_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerURL`].OutputValue' \
            --output text)

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # üöÄ Application Deployment Complete

          ## Deployment Information
          - **Environment**: \`${{ github.event.inputs.environment || 'production' }}\`
          - **Instances Deployed**: \`${{ steps.get-instances.outputs.instance_count }}\`
          - **Migrations Run**: \`${{ github.event.inputs.run_migrations || 'true' }}\`
          - **Commit**: \`${{ github.sha }}\`

          ## Endpoints
          - **API URL**: [$ALB_URL]($ALB_URL)
          - **Health Check**: [$ALB_URL/health]($ALB_URL/health)
          - **API Docs**: [$ALB_URL/docs]($ALB_URL/docs)

          ## Verification
          \`\`\`bash
          # Test health endpoint
          curl $ALB_URL/health

          # Test API endpoint
          curl -X POST $ALB_URL/api/v1/chats/ \\
            -H "Content-Type: application/json" \\
            -d '{"message": "Hello from deployed API!"}'
          \`\`\`

          ## SSH Access
          \`\`\`bash
          # SSH to instances
          ssh -i your-key.pem ubuntu@<instance-ip>

          # View logs
          sudo tail -f /var/log/bedrock-backend.log

          # Check supervisor status
          sudo supervisorctl status bedrock-backend
          \`\`\`

          ---
          *Deployed by GitHub Actions - Commit: ${{ github.sha }}*
          EOF

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    steps:
      - name: Send Slack notification
        if: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "Application Deployment ${{ needs.deploy.result == 'success' && '‚úÖ Successful' || '‚ùå Failed' }}",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "${{ needs.deploy.result == 'success' && '‚úÖ' || '‚ùå' }} Application Deployment"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Environment:*\n${{ github.event.inputs.environment || 'production' }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Status:*\n${{ needs.deploy.result }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n${{ github.ref_name }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Commit:*\n<${{ github.event.head_commit.url }}|${{ github.sha }}>}"
                    }
                  ]
                }
              ]
            }
