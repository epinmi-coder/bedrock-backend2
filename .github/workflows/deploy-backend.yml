name: Deploy Bedrock Backend to AWS

on:
  push:
    branches:
      - main
      - production
    paths:
      - "src/**"
      - "main.py"
      - "requirements.txt"
      - "Dockerfile"
      - ".github/workflows/deploy-backend.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: bedrock-backend
  STACK_NAME: bedrock-backend-stack

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-uri: ${{ steps.push.outputs.image-uri }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata for Docker
        id: meta
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${SHORT_SHA}-${TIMESTAMP}"
          echo "tags=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "latest=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest" >> $GITHUB_OUTPUT
          echo "Image tag: ${IMAGE_TAG}"

      - name: Build Docker image
        run: |
          docker build -t ${{ steps.meta.outputs.tags }} .
          docker tag ${{ steps.meta.outputs.tags }} ${{ steps.meta.outputs.latest }}

      - name: Test Docker image
        run: |
          # Test building the image
          echo "Docker image built successfully"
          echo "Image size:"
          docker images ${{ steps.meta.outputs.tags }} --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

      - name: Push Docker image to ECR
        id: push
        run: |
          docker push ${{ steps.meta.outputs.tags }}
          docker push ${{ steps.meta.outputs.latest }}
          echo "image-uri=${{ steps.meta.outputs.tags }}" >> $GITHUB_OUTPUT
          echo "Successfully pushed: ${{ steps.meta.outputs.tags }}"

      - name: Scan Docker image for vulnerabilities
        continue-on-error: true
        run: |
          aws ecr start-image-scan \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=latest \
            --region ${{ env.AWS_REGION }} || true

  deploy-to-ec2:
    name: Deploy to EC2 Instances
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Auto Scaling Group name
        id: get-asg
        run: |
          ASG_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='AutoScalingGroupName'].OutputValue" \
            --output text)
          echo "asg-name=${ASG_NAME}" >> $GITHUB_OUTPUT
          echo "Auto Scaling Group: ${ASG_NAME}"

      - name: Get EC2 instance IDs from Auto Scaling Group
        id: get-instances
        run: |
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ steps.get-asg.outputs.asg-name }} \
            --query "AutoScalingGroups[0].Instances[?HealthStatus=='Healthy'].InstanceId" \
            --output text)
          echo "instance-ids=${INSTANCE_IDS}" >> $GITHUB_OUTPUT
          echo "Instance IDs: ${INSTANCE_IDS}"

      - name: Deploy to EC2 instances via SSM
        run: |
          INSTANCE_IDS="${{ steps.get-instances.outputs.instance-ids }}"
          IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"

          if [ -z "$INSTANCE_IDS" ]; then
            echo "No healthy instances found!"
            exit 1
          fi

          echo "Deploying to instances: $INSTANCE_IDS"

          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Deploying to instance: $INSTANCE_ID"
            
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids $INSTANCE_ID \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=['/opt/bedrock-backend/deploy.sh $IMAGE_URI']" \
              --timeout-seconds 600 \
              --query "Command.CommandId" \
              --output text)
            
            echo "Command ID: $COMMAND_ID"
            
            # Wait for command to complete
            aws ssm wait command-executed \
              --command-id $COMMAND_ID \
              --instance-id $INSTANCE_ID \
              --region ${{ env.AWS_REGION }}
            
            # Get command output
            STATUS=$(aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id $INSTANCE_ID \
              --query "Status" \
              --output text)
            
            echo "Deployment status for $INSTANCE_ID: $STATUS"
            
            if [ "$STATUS" != "Success" ]; then
              echo "Deployment failed for instance $INSTANCE_ID"
              aws ssm get-command-invocation \
                --command-id $COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi
          done

          echo "‚úÖ Deployment successful to all instances!"

      - name: Verify deployment health
        run: |
          # Get ALB DNS from CloudFormation
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
            --output text)

          echo "Load Balancer: http://${ALB_DNS}"

          # Wait for health checks to pass
          echo "Waiting for health checks..."
          sleep 30

          # Test health endpoint
          for i in {1..10}; do
            if curl -f -s "http://${ALB_DNS}/health" | grep -q "healthy"; then
              echo "‚úÖ Health check passed!"
              curl -s "http://${ALB_DNS}/health" | jq .
              exit 0
            fi
            echo "Attempt $i/10 - waiting..."
            sleep 10
          done

          echo "‚ùå Health check failed after 10 attempts"
          exit 1

  notify:
    name: Send Deployment Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-ec2]
    if: always()

    steps:
      - name: Deployment Status
        run: |
          if [ "${{ needs.deploy-to-ec2.result }}" == "success" ]; then
            echo "üöÄ Deployment successful!"
            echo "Image: ${{ needs.build-and-push.outputs.image-uri }}"
            echo "Environment: ${{ github.ref_name }}"
          else
            echo "‚ùå Deployment failed!"
            exit 1
          fi
