name: Deploy Bedrock Backend to AWS

on:
  push:
    branches:
      - main
      - production
    paths:
      - "src/**"
      - "main.py"
      - "requirements.txt"
      - "Dockerfile"
      - "cloudformation/**"
      - ".github/workflows/deploy-backend.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: bedrock-backend
  STACK_NAME: bedrock-backend-stack

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-uri: ${{ steps.push.outputs.image-uri }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create ECR repository if it doesn't exist
        run: |
          echo "Checking if ECR repository exists..."
          if aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "âœ… ECR repository '${{ env.ECR_REPOSITORY }}' already exists"
          else
            echo "ğŸ“¦ Creating ECR repository '${{ env.ECR_REPOSITORY }}'..."
            aws ecr create-repository \
              --repository-name ${{ env.ECR_REPOSITORY }} \
              --region ${{ env.AWS_REGION }} \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
            echo "âœ… ECR repository created successfully!"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata for Docker
        id: meta
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${SHORT_SHA}-${TIMESTAMP}"
          echo "tags=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "latest=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest" >> $GITHUB_OUTPUT
          echo "Image tag: ${IMAGE_TAG}"

      - name: Build Docker image
        run: |
          docker build -t ${{ steps.meta.outputs.tags }} .
          docker tag ${{ steps.meta.outputs.tags }} ${{ steps.meta.outputs.latest }}

      - name: Test Docker image
        run: |
          # Test building the image
          echo "Docker image built successfully"
          echo "Image size:"
          docker images ${{ steps.meta.outputs.tags }} --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

      - name: Push Docker image to ECR
        id: push
        run: |
          docker push ${{ steps.meta.outputs.tags }}
          docker push ${{ steps.meta.outputs.latest }}
          echo "image-uri=${{ steps.meta.outputs.tags }}" >> $GITHUB_OUTPUT
          echo "Successfully pushed: ${{ steps.meta.outputs.tags }}"

      - name: Scan Docker image for vulnerabilities
        continue-on-error: true
        run: |
          aws ecr start-image-scan \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=latest \
            --region ${{ env.AWS_REGION }} || true

  deploy-to-ec2:
    name: Deploy to EC2 Instances
    runs-on: ubuntu-latest
    needs: build-and-push

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check if CloudFormation stack exists
        id: check-stack
        continue-on-error: true
        run: |
          echo "Checking for existing CloudFormation stack..."
          echo "Stack name: ${{ env.STACK_NAME }}"
          echo "Region: ${{ env.AWS_REGION }}"

          if aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null; then
            echo "stack-exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Stack exists, will perform rolling update"
          else
            echo "stack-exists=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Stack does not exist, will create new infrastructure"
          fi

      - name: Get default VPC and subnets
        id: get-vpc
        if: steps.check-stack.outputs.stack-exists == 'false'
        run: |
          # Get default VPC in us-east-2
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=is-default,Values=true" \
            --query "Vpcs[0].VpcId" \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "vpc-id=${VPC_ID}" >> $GITHUB_OUTPUT
          echo "Default VPC ID: ${VPC_ID}"

          # Get at least 2 subnets from default VPC
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=${VPC_ID}" \
            --query "Subnets[0:2].SubnetId" \
            --output text \
            --region ${{ env.AWS_REGION }} | tr '\t' ',')
          echo "subnet-ids=${SUBNET_IDS}" >> $GITHUB_OUTPUT
          echo "Subnet IDs: ${SUBNET_IDS}"

      - name: Create CloudFormation stack (first deployment)
        if: steps.check-stack.outputs.stack-exists == 'false'
        run: |
          echo "Creating CloudFormation stack for first deployment..."
          echo "Using default VPC and subnets in us-east-2"
          echo "Instance type: t3.medium (Faster deployment)"

          # Build parameters JSON with proper escaping using jq
          jq -n \
            --arg env "production" \
            --arg instanceType "t3.medium" \
            --arg keyPair "${{ secrets.EC2_KEY_PAIR_NAME }}" \
            --arg dockerImage "${{ needs.build-and-push.outputs.image-uri }}" \
            --arg dbUrl "${{ secrets.DATABASE_URL }}" \
            --arg awsKeyId "${{ secrets.AWS_ACCESS_KEY_ID }}" \
            --arg awsSecret "${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            --arg jwtSecret "${{ secrets.JWT_SECRET }}" \
            --arg frontendDomain "localhost:5173" \
            --arg mailServer "${{ secrets.MAIL_SERVER }}" \
            --arg mailPort "${{ secrets.MAIL_PORT }}" \
            --arg mailUser "${{ secrets.MAIL_USERNAME }}" \
            --arg mailPass "${{ secrets.MAIL_PASSWORD }}" \
            --arg mailFrom "${{ secrets.MAIL_FROM }}" \
            --arg mailFromName "Security Platform" \
            --arg domain "TBD" \
            --arg vpcId "${{ steps.get-vpc.outputs.vpc-id }}" \
            --arg subnetIds "${{ steps.get-vpc.outputs.subnet-ids }}" \
            --arg minSize "1" \
            --arg maxSize "3" \
            --arg desiredCap "1" \
            '[
              {ParameterKey: "Environment", ParameterValue: $env},
              {ParameterKey: "InstanceType", ParameterValue: $instanceType},
              {ParameterKey: "KeyPairName", ParameterValue: $keyPair},
              {ParameterKey: "DockerImage", ParameterValue: $dockerImage},
              {ParameterKey: "DatabaseURL", ParameterValue: $dbUrl},
              {ParameterKey: "AWSAccessKeyId", ParameterValue: $awsKeyId},
              {ParameterKey: "AWSSecretAccessKey", ParameterValue: $awsSecret},
              {ParameterKey: "JWTSecret", ParameterValue: $jwtSecret},
              {ParameterKey: "FrontendDomain", ParameterValue: $frontendDomain},
              {ParameterKey: "MailServer", ParameterValue: $mailServer},
              {ParameterKey: "MailPort", ParameterValue: $mailPort},
              {ParameterKey: "MailUsername", ParameterValue: $mailUser},
              {ParameterKey: "MailPassword", ParameterValue: $mailPass},
              {ParameterKey: "MailFrom", ParameterValue: $mailFrom},
              {ParameterKey: "MailFromName", ParameterValue: $mailFromName},
              {ParameterKey: "Domain", ParameterValue: $domain},
              {ParameterKey: "VpcId", ParameterValue: $vpcId},
              {ParameterKey: "SubnetIds", ParameterValue: $subnetIds},
              {ParameterKey: "MinSize", ParameterValue: $minSize},
              {ParameterKey: "MaxSize", ParameterValue: $maxSize},
              {ParameterKey: "DesiredCapacity", ParameterValue: $desiredCap}
            ]' > /tmp/cf-params.json

          aws cloudformation create-stack \
            --stack-name ${{ env.STACK_NAME }} \
            --template-body file://cloudformation/bedrock-docker-ec2.yaml \
            --parameters file:///tmp/cf-params.json \
            --capabilities CAPABILITY_NAMED_IAM \
            --region ${{ env.AWS_REGION }}

          echo "Waiting for stack creation to complete (this may take 8-12 minutes)..."
          echo "Monitoring stack events for troubleshooting..."

          # Start background monitoring of stack events
          (
            while true; do
              aws cloudformation describe-stack-events \
                --stack-name ${{ env.STACK_NAME }} \
                --region ${{ env.AWS_REGION }} \
                --max-items 5 \
                --query "StackEvents[?ResourceStatus=='CREATE_FAILED' || ResourceStatus=='UPDATE_FAILED'].[LogicalResourceId,ResourceStatusReason]" \
                --output text 2>/dev/null || true
              sleep 30
            done
          ) &
          MONITOR_PID=$!

          # Wait with timeout (max 30 minutes = 1800 seconds)
          # EC2 instances need time to: pull images, start containers, pass health checks
          timeout 1800 aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} || {
            EXIT_CODE=$?
            kill $MONITOR_PID 2>/dev/null || true
            
            echo "âš ï¸ Stack creation encountered an issue (exit code: $EXIT_CODE)"
            echo ""
            echo "ğŸ“‹ Recent Stack Events (last 30):"
            aws cloudformation describe-stack-events \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --max-items 30 \
              --query "StackEvents[*].[Timestamp,LogicalResourceId,ResourceStatus,ResourceStatusReason]" \
              --output table
            
            if [ $EXIT_CODE -eq 124 ]; then
              echo "âŒ Timeout: Stack creation took longer than 30 minutes"
              echo ""
              echo "ğŸ” Check CloudWatch Logs for detailed instance startup logs:"
              echo "   CloudWatch â†’ Log Groups â†’ /aws/ec2/bedrock-backend â†’ latest stream"
            fi
            
            exit 1
          }

          # Stop monitoring
          kill $MONITOR_PID 2>/dev/null || true          echo "Stack created successfully!"

          # Get and display ALB DNS
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
            --output text \
            --region ${{ env.AWS_REGION }}

          echo "ğŸš€ Backend deployed successfully!"
          echo "ALB DNS: http://${ALB_DNS}"
          echo "Health Check: http://${ALB_DNS}/health"
          echo ""
          echo "Update your frontend VITE_API_URL to: http://${ALB_DNS}"
          echo ""
          echo "â© First deployment complete! Subsequent deployments will use zero-downtime updates."

      - name: First deployment complete
        if: steps.check-stack.outputs.stack-exists == 'false'
        run: |
          echo "âœ… First deployment complete!"
          echo "The infrastructure has been created and containers are running."
          echo "No further deployment steps needed for first run."
          echo ""
          echo "Future deployments will automatically update running containers."

      - name: Get Auto Scaling Group name
        id: get-asg
        if: steps.check-stack.outputs.stack-exists == 'true'
        continue-on-error: true
        run: |
          echo "ğŸ” Getting Auto Scaling Group from existing stack..."

          # Verify stack exists before querying
          if ! aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query "Stacks[0].StackStatus" \
            --output text 2>/dev/null; then
            echo "âš ï¸ Stack not found. This is a first deployment."
            echo "asg-name=" >> $GITHUB_OUTPUT
            exit 0
          fi

          ASG_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query "Stacks[0].Outputs[?OutputKey=='AutoScalingGroupName'].OutputValue" \
            --output text)

          if [ -z "$ASG_NAME" ] || [ "$ASG_NAME" == "None" ]; then
            echo "âš ï¸ Auto Scaling Group not found in stack outputs"
            echo "asg-name=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "asg-name=${ASG_NAME}" >> $GITHUB_OUTPUT
          echo "âœ… Auto Scaling Group: ${ASG_NAME}"

      - name: Get EC2 instance IDs from Auto Scaling Group
        id: get-instances
        if: steps.check-stack.outputs.stack-exists == 'true' && steps.get-asg.outputs.asg-name != ''
        continue-on-error: true
        run: |
          ASG_NAME="${{ steps.get-asg.outputs.asg-name }}"

          if [ -z "$ASG_NAME" ]; then
            echo "âš ï¸ No Auto Scaling Group name available. Skipping instance update."
            echo "instance-ids=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "ğŸ” Getting healthy instances from ASG: $ASG_NAME"

          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names "$ASG_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[?HealthStatus=='Healthy'].InstanceId" \
            --output text 2>/dev/null || echo "")

          echo "instance-ids=${INSTANCE_IDS}" >> $GITHUB_OUTPUT

          if [ -z "$INSTANCE_IDS" ]; then
            echo "âš ï¸ No healthy instances found (they may still be initializing)"
          else
            echo "âœ… Found instances: ${INSTANCE_IDS}"
          fi

      - name: Deploy to EC2 instances via SSM
        if: steps.check-stack.outputs.stack-exists == 'true' && steps.get-instances.outputs.instance-ids != ''
        continue-on-error: false
        run: |
          INSTANCE_IDS="${{ steps.get-instances.outputs.instance-ids }}"
          IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"

          if [ -z "$INSTANCE_IDS" ]; then
            echo "âš ï¸ No healthy instances available for deployment"
            echo "ğŸ’¡ Instances may still be initializing. Check AWS Console in a few minutes."
            exit 0
          fi

          echo "ğŸš€ Deploying to instances: $INSTANCE_IDS"
          echo "ğŸ“¦ Image: $IMAGE_URI"

          for INSTANCE_ID in $INSTANCE_IDS; do
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“ Deploying to instance: $INSTANCE_ID"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            COMMAND_ID=$(aws ssm send-command \
              --instance-ids $INSTANCE_ID \
              --document-name "AWS-RunShellScript" \
              --parameters "commands=['/opt/bedrock-backend/deploy.sh $IMAGE_URI']" \
              --timeout-seconds 600 \
              --query "Command.CommandId" \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            echo "ğŸ“ SSM Command ID: $COMMAND_ID"
            echo "â³ Waiting for deployment to complete (max 10 minutes)..."
            
            # Wait for command to complete
            aws ssm wait command-executed \
              --command-id $COMMAND_ID \
              --instance-id $INSTANCE_ID \
              --region ${{ env.AWS_REGION }}
            
            # Get command status and output
            STATUS=$(aws ssm get-command-invocation \
              --command-id $COMMAND_ID \
              --instance-id $INSTANCE_ID \
              --query "Status" \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            echo ""
            echo "ğŸ“Š Deployment Status: $STATUS"
            
            if [ "$STATUS" == "Success" ]; then
              echo "âœ… Deployment successful for $INSTANCE_ID"
              
              # Show deployment output
              echo ""
              echo "ğŸ“„ Deployment Output:"
              aws ssm get-command-invocation \
                --command-id $COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --query "StandardOutputContent" \
                --output text \
                --region ${{ env.AWS_REGION }} | tail -20
            else
              echo "âŒ Deployment failed for instance $INSTANCE_ID"
              echo ""
              echo "ğŸ“„ Error Output:"
              aws ssm get-command-invocation \
                --command-id $COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --query "StandardErrorContent" \
                --output text \
                --region ${{ env.AWS_REGION }}
              echo ""
              echo "ğŸ“„ Standard Output:"
              aws ssm get-command-invocation \
                --command-id $COMMAND_ID \
                --instance-id $INSTANCE_ID \
                --query "StandardOutputContent" \
                --output text \
                --region ${{ env.AWS_REGION }}
              exit 1
            fi
          done

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Deployment successful to all instances!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Verify deployment health
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ¥ Verifying Deployment Health"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # Get ALB DNS from CloudFormation
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" \
            --output text \
            --region ${{ env.AWS_REGION }})

          if [ -z "$ALB_DNS" ]; then
            echo "âš ï¸ Could not retrieve ALB DNS from CloudFormation stack"
            echo "ğŸ“ Check AWS Console â†’ CloudFormation â†’ ${{ env.STACK_NAME }} â†’ Outputs"
            exit 0
          fi

          echo "ğŸŒ Load Balancer DNS: $ALB_DNS"
          echo "ğŸ”— Backend URL: http://${ALB_DNS}"
          echo ""

          # Wait for target groups to be healthy (first deployment)
          echo "â³ Waiting for health checks to stabilize (90 seconds)..."
          sleep 90

          # Comprehensive health check
          echo "ğŸ” Testing health endpoint..."
          HEALTH_ATTEMPTS=0
          MAX_HEALTH_ATTEMPTS=15

          while [ $HEALTH_ATTEMPTS -lt $MAX_HEALTH_ATTEMPTS ]; do
            HEALTH_ATTEMPTS=$((HEALTH_ATTEMPTS + 1))
            echo "ğŸ¥ Health check attempt $HEALTH_ATTEMPTS/$MAX_HEALTH_ATTEMPTS..."
            
            if RESPONSE=$(curl -f -s --max-time 10 "http://${ALB_DNS}/health" 2>&1); then
              echo "âœ… Health check PASSED!"
              echo ""
              echo "ğŸ“„ Health Response:"
              echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
              echo ""
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo "ğŸ‰ DEPLOYMENT SUCCESSFUL!"
              echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
              echo ""
              echo "ğŸ“Œ Backend URL: http://${ALB_DNS}"
              echo "ğŸ“Œ Health Endpoint: http://${ALB_DNS}/health"
              echo "ğŸ“Œ API Docs: http://${ALB_DNS}/api/v1/docs"
              echo ""
              echo "ğŸ”„ Update your frontend VITE_API_URL to:"
              echo "   http://${ALB_DNS}"
              echo ""
              exit 0
            fi
            
            echo "â³ Waiting (attempt $HEALTH_ATTEMPTS/$MAX_HEALTH_ATTEMPTS)..."
            sleep 15
          done

          echo ""
          echo "âš ï¸ Health check did not pass within the timeout period"
          echo ""
          echo "ğŸ“‹ Troubleshooting Information:"
          echo "1. Check Target Group health in AWS Console:"
          echo "   EC2 â†’ Target Groups â†’ ${{ env.STACK_NAME }}"
          echo ""
          echo "2. Check CloudWatch Logs:"
          echo "   CloudWatch â†’ Log Groups â†’ /aws/ec2/bedrock-backend"
          echo ""
          echo "3. The backend should still be accessible at:"
          echo "   http://${ALB_DNS}"
          echo ""
          echo "Note: First deployments may take 3-5 minutes for targets to become healthy"
          echo ""
          exit 0

  notify:
    name: Send Deployment Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-ec2]
    if: always()

    steps:
      - name: Deployment Status
        run: |
          if [ "${{ needs.deploy-to-ec2.result }}" == "success" ]; then
            echo "ğŸš€ Deployment successful!"
            echo "Image: ${{ needs.build-and-push.outputs.image-uri }}"
            echo "Environment: ${{ github.ref_name }}"
          else
            echo "âŒ Deployment failed!"
            exit 1
          fi
