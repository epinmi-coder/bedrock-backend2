AWSTemplateFormatVersion: "2010-09-09"
Description: "Bedrock Backend - Docker deployment on EC2 with ALB (HTTP only)"

Parameters:
  Environment:
    Type: String
    Default: production
    Description: Environment name (production, staging, development)

  InstanceType:
    Type: String
    Default: t3.medium
    AllowedValues:
      - t3.medium
      - t3.large
      - t2.medium
    Description: EC2 instance type (t3.medium recommended for faster deployment and running FastAPI + Celery + Redis containers)

  KeyPairName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: EC2 Key Pair for SSH access

  DockerImage:
    Type: String
    Description: Docker image URI from ECR (e.g., 123456789012.dkr.ecr.us-east-1.amazonaws.com/bedrock-backend:latest)

  DatabaseURL:
    Type: String
    NoEcho: true
    Description: PostgreSQL database connection string

  AWSAccessKeyId:
    Type: String
    NoEcho: true
    Description: AWS Access Key ID for Bedrock

  AWSSecretAccessKey:
    Type: String
    NoEcho: true
    Description: AWS Secret Access Key for Bedrock

  JWTSecret:
    Type: String
    NoEcho: true
    Description: JWT secret key for authentication

  FrontendDomain:
    Type: String
    Default: "localhost:5173"
    Description: Frontend domain for email verification links (update later with CloudFront URL)

  MailServer:
    Type: String
    Description: SMTP mail server (e.g., smtp.gmail.com)

  MailPort:
    Type: Number
    Default: 587
    Description: SMTP port (587 for TLS, 465 for SSL)

  MailUsername:
    Type: String
    Description: Email username for SMTP authentication

  MailPassword:
    Type: String
    NoEcho: true
    Description: Email password for SMTP authentication

  MailFrom:
    Type: String
    Description: Sender email address

  MailFromName:
    Type: String
    Default: "Security Platform"
    Description: Sender name for emails

  Domain:
    Type: String
    Description: Backend domain (e.g., api.yourdomain.com or ALB DNS)

  MinSize:
    Type: Number
    Default: 1
    Description: Minimum number of EC2 instances

  MaxSize:
    Type: Number
    Default: 3
    Description: Maximum number of EC2 instances

  DesiredCapacity:
    Type: Number
    Default: 1
    Description: Desired number of EC2 instances

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID (use default VPC or existing VPC)

  SubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Subnet IDs for ALB and EC2 instances (select at least 2 in different AZs)

Resources:
  # ==================== Security Groups ====================
  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub ${Environment}-bedrock-alb-sg
      GroupDescription: Security group for Application Load Balancer - HTTP/HTTPS only
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        # Allow HTTP from anywhere
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: Allow HTTP from all origins
        # Allow HTTPS from anywhere (for future SSL setup)
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: Allow HTTPS from all origins
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: !Sub ${Environment}-bedrock-alb-sg
        - Key: Environment
          Value: !Ref Environment

  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub ${Environment}-bedrock-ec2-sg
      GroupDescription: Security group for EC2 instances running Docker
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        # Allow traffic from ALB to Docker container port 8000
        - IpProtocol: tcp
          FromPort: 8000
          ToPort: 8000
          SourceSecurityGroupId: !Ref ALBSecurityGroup
          Description: Allow traffic from ALB to Docker port 8000
        # Allow SSH for maintenance
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
          Description: Allow SSH access (restrict this in production!)
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
          Description: Allow all outbound traffic
      Tags:
        - Key: Name
          Value: !Sub ${Environment}-bedrock-ec2-sg
        - Key: Environment
          Value: !Ref Environment

  # ==================== IAM Roles ====================
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${Environment}-bedrock-ec2-role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: "*"
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogStreams
                Resource: !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/ec2/bedrock-backend*

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub ${Environment}-bedrock-ec2-profile
      Roles:
        - !Ref EC2Role

  # ==================== Application Load Balancer ====================
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${Environment}-bedrock-alb
      Type: application
      Scheme: internet-facing
      IpAddressType: ipv4
      Subnets: !Ref SubnetIds
      SecurityGroups:
        - !Ref ALBSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub ${Environment}-bedrock-alb
        - Key: Environment
          Value: !Ref Environment

  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub ${Environment}-bedrock-tg
      Port: 8000
      Protocol: HTTP
      VpcId: !Ref VpcId
      HealthCheckEnabled: true
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckIntervalSeconds: 15
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2
      Matcher:
        HttpCode: 200
      TargetType: instance
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: "30"
      Tags:
        - Key: Name
          Value: !Sub ${Environment}-bedrock-tg
        - Key: Environment
          Value: !Ref Environment

  # HTTP Listener (Port 80)
  ALBListenerHTTP:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup

  # HTTPS Listener placeholder (commented out until SSL certificate is available)
  # ALBListenerHTTPS:
  #   Type: AWS::ElasticLoadBalancingV2::Listener
  #   Properties:
  #     LoadBalancerArn: !Ref ApplicationLoadBalancer
  #     Port: 443
  #     Protocol: HTTPS
  #     Certificates:
  #       - CertificateArn: arn:aws:acm:region:account-id:certificate/certificate-id
  #     DefaultActions:
  #       - Type: forward
  #         TargetGroupArn: !Ref TargetGroup

  # ==================== Launch Template ====================
  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub ${Environment}-bedrock-lt
      LaunchTemplateData:
        # Use SSM parameter to get latest Ubuntu 22.04 AMI for us-east-2
        # Note: Using ebs-gp2 (gp3 parameter not available in all regions)
        ImageId: !Sub "{{resolve:ssm:/aws/service/canonical/ubuntu/server/22.04/stable/current/amd64/hvm/ebs-gp2/ami-id}}"
        InstanceType: !Ref InstanceType
        KeyName: !Ref KeyPairName
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        SecurityGroupIds:
          - !Ref EC2SecurityGroup
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub ${Environment}-bedrock-instance
              - Key: Environment
                Value: !Ref Environment
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            # Bedrock Backend Deployment Script
            # Comprehensive error handling and logging for production deployment

            set -e  # Exit on error
            set -o pipefail  # Catch errors in pipes

            # Enhanced logging function
            log_info() {
                echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') - $1"
            }

            log_error() {
                echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
            }

            log_success() {
                echo "[SUCCESS] $(date '+%Y-%m-%d %H:%M:%S') - $1"
            }

            # Log everything to user-data.log
            exec > >(tee /var/log/user-data.log)
            exec 2>&1

            log_info "=========================================="
            log_info "Starting Bedrock Backend Setup"
            log_info "Instance ID: $(ec2-metadata --instance-id | cut -d ' ' -f 2)"
            log_info "Region: ${AWS::Region}"
            log_info "=========================================="

            # Function to check command success
            check_status() {
                if [ $? -eq 0 ]; then
                    log_success "$1"
                else
                    log_error "$1 failed"
                    exit 1
                fi
            }

            # Update system packages (skip upgrade to save time)
            log_info "Updating package lists..."
            apt-get update -y
            check_status "Package list update"

            # Install Docker
            log_info "Installing Docker prerequisites..."
            apt-get install -y apt-transport-https ca-certificates curl software-properties-common
            check_status "Docker prerequisites installation"

            log_info "Adding Docker GPG key..."
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            check_status "Docker GPG key installation"

            log_info "Adding Docker repository..."
            echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
            apt-get update -y

            log_info "Installing Docker Engine..."
            apt-get install -y docker-ce docker-ce-cli containerd.io
            check_status "Docker Engine installation"

            # Start Docker service
            log_info "Starting Docker service..."
            systemctl enable docker
            systemctl start docker
            check_status "Docker service start"

            # Verify Docker is running
            docker --version
            check_status "Docker version check"

            # Install Docker Compose
            log_info "Installing Docker Compose..."
            curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
            docker-compose --version
            check_status "Docker Compose installation"

            # Install AWS CLI and CloudWatch agent
            log_info "Installing AWS CLI..."
            apt-get install -y awscli
            check_status "AWS CLI installation"

            log_info "Downloading CloudWatch agent..."
            wget -q https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
            check_status "CloudWatch agent download"

            log_info "Installing CloudWatch agent..."
            dpkg -i amazon-cloudwatch-agent.deb
            check_status "CloudWatch agent installation"

            # Create application directory
            log_info "Creating application directory..."
            mkdir -p /opt/bedrock-backend
            cd /opt/bedrock-backend
            check_status "Application directory creation"

            # Create CloudWatch log group BEFORE starting containers
            log_info "Creating CloudWatch log group..."
            aws logs create-log-group \
              --log-group-name /aws/ec2/bedrock-backend \
              --region ${AWS::Region} 2>/dev/null && log_success "Log group created" || log_info "Log group already exists"

            # Set retention policy
            aws logs put-retention-policy \
              --log-group-name /aws/ec2/bedrock-backend \
              --retention-in-days 7 \
              --region ${AWS::Region} 2>/dev/null || log_info "Retention policy already set"

            # Login to ECR
            log_info "Logging into Amazon ECR..."
            aws ecr get-login-password --region ${AWS::Region} | docker login --username AWS --password-stdin ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com
            check_status "ECR login"

            # Create environment file for Docker
            log_info "Creating environment configuration..."
            cat > .env <<'EOF'
            # Database
            DATABASE_URL=${DatabaseURL}

            # AWS Configuration
            AWS_ACCESS_KEY_ID=${AWSAccessKeyId}
            AWS_SECRET_ACCESS_KEY=${AWSSecretAccessKey}
            AWS_DEFAULT_REGION=${AWS::Region}
            AWS_REGION=${AWS::Region}

            # Authentication
            JWT_SECRET=${JWTSecret}
            JWT_ALGORITHM=HS256
            ENABLE_AUTH=true

            # Redis Configuration (for Celery)
            REDIS_HOST=redis
            REDIS_PORT=6379
            REDIS_URL=redis://redis:6379/0

            # Email Configuration (SMTP)
            MAIL_SERVER=${MailServer}
            MAIL_PORT=${MailPort}
            MAIL_USERNAME=${MailUsername}
            MAIL_PASSWORD=${MailPassword}
            MAIL_FROM=${MailFrom}
            MAIL_FROM_NAME=${MailFromName}
            MAIL_STARTTLS=true
            MAIL_SSL_TLS=false
            USE_CREDENTIALS=true
            VALIDATE_CERTS=true

            # Domain Configuration
            DOMAIN=${Domain}
            FRONTEND_DOMAIN=${FrontendDomain}

            # CORS Configuration - Allow all origins for testing
            ALLOWED_ORIGINS='["*"]'

            # Environment
            ENVIRONMENT=${Environment}

            # Bedrock Configuration
            BEDROCK_MODEL_ID=anthropic.claude-3-haiku-20240307-v1:0
            BEDROCK_MAX_TOKENS=4000
            BEDROCK_TEMPERATURE=0.1
            EOF
            check_status "Environment file creation"

            # Create Docker network for container communication
            log_info "Creating Docker network..."
            docker network create bedrock-network 2>/dev/null && log_success "Network created" || log_info "Network already exists"

            # Pull Docker image
            log_info "Pulling Docker image: ${DockerImage}"
            docker pull ${DockerImage}
            check_status "Docker image pull"

            # Start Redis container
            log_info "Starting Redis container..."
            docker run -d \
              --name redis \
              --restart unless-stopped \
              --network bedrock-network \
              --log-driver=awslogs \
              --log-opt awslogs-region=${AWS::Region} \
              --log-opt awslogs-group=/aws/ec2/bedrock-backend \
              --log-opt awslogs-stream-prefix=redis \
              redis:7-alpine
            check_status "Redis container start"

            # Wait for Redis to be ready
            log_info "Waiting for Redis to be ready..."
            sleep 3
            docker exec redis redis-cli ping && log_success "Redis is ready" || log_error "Redis health check failed"

            # Start main FastAPI container
            log_info "Starting FastAPI container..."
            docker run -d \
              --name bedrock-backend \
              --restart unless-stopped \
              --network bedrock-network \
              -p 8000:8000 \
              -e SERVICE_TYPE=api \
              --env-file .env \
              --log-driver=awslogs \
              --log-opt awslogs-region=${AWS::Region} \
              --log-opt awslogs-group=/aws/ec2/bedrock-backend \
              --log-opt awslogs-stream-prefix=fastapi \
              ${DockerImage}
            check_status "FastAPI container start"

            # Start Celery worker container
            log_info "Starting Celery worker container..."
            docker run -d \
              --name bedrock-celery-worker \
              --restart unless-stopped \
              --network bedrock-network \
              -e SERVICE_TYPE=celery \
              --env-file .env \
              --log-driver=awslogs \
              --log-opt awslogs-region=${AWS::Region} \
              --log-opt awslogs-group=/aws/ec2/bedrock-backend \
              --log-opt awslogs-stream-prefix=celery \
              ${DockerImage}
            check_status "Celery worker start"

            # Comprehensive health check
            log_info "Performing comprehensive health checks..."
            sleep 5

            # Check if containers are running
            log_info "Verifying container status..."
            FASTAPI_RUNNING=$(docker ps --filter "name=bedrock-backend" --filter "status=running" -q)
            CELERY_RUNNING=$(docker ps --filter "name=bedrock-celery-worker" --filter "status=running" -q)
            REDIS_RUNNING=$(docker ps --filter "name=redis" --filter "status=running" -q)

            if [ -z "$FASTAPI_RUNNING" ]; then
                log_error "FastAPI container is not running!"
                docker logs bedrock-backend 2>&1 | tail -50
                exit 1
            fi
            log_success "FastAPI container is running"

            if [ -z "$CELERY_RUNNING" ]; then
                log_error "Celery worker container is not running!"
                docker logs bedrock-celery-worker 2>&1 | tail -50
                exit 1
            fi
            log_success "Celery worker is running"

            if [ -z "$REDIS_RUNNING" ]; then
                log_error "Redis container is not running!"
                docker logs redis 2>&1 | tail -50
                exit 1
            fi
            log_success "Redis is running"

            # Wait for FastAPI health endpoint
            log_info "Waiting for FastAPI health endpoint..."
            HEALTH_CHECK_ATTEMPTS=0
            MAX_ATTEMPTS=20

            while [ $HEALTH_CHECK_ATTEMPTS -lt $MAX_ATTEMPTS ]; do
                if curl -f http://localhost:8000/health 2>/dev/null; then
                    log_success "Health check passed!"
                    break
                fi
                HEALTH_CHECK_ATTEMPTS=$((HEALTH_CHECK_ATTEMPTS + 1))
                log_info "Health check attempt $HEALTH_CHECK_ATTEMPTS/$MAX_ATTEMPTS..."
                sleep 3
            done

            if [ $HEALTH_CHECK_ATTEMPTS -eq $MAX_ATTEMPTS ]; then
                log_error "Health check failed after $MAX_ATTEMPTS attempts"
                log_error "FastAPI container logs:"
                docker logs bedrock-backend 2>&1 | tail -100
                exit 1
            fi

            # Final verification
            log_info "Performing final verification..."
            if ! docker ps | grep -q bedrock-backend; then
                log_error "FastAPI container stopped after health check!"
                docker logs bedrock-backend 2>&1 | tail -100
                exit 1
            fi

            log_success "All containers are healthy and running!"
            log_info "Container status:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

            # Create CloudWatch agent configuration
            log_info "Configuring CloudWatch agent..."
            cat > /opt/aws/amazon-cloudwatch-agent/etc/config.json <<'CWEOF'
            {
              "logs": {
                "logs_collected": {
                  "files": {
                    "collect_list": [
                      {
                        "file_path": "/var/log/user-data.log",
                        "log_group_name": "/aws/ec2/bedrock-backend",
                        "log_stream_name": "{instance_id}/user-data",
                        "retention_in_days": 7
                      }
                    ]
                  }
                }
              },
              "metrics": {
                "namespace": "BedrockBackend",
                "metrics_collected": {
                  "cpu": {
                    "measurement": [
                      {
                        "name": "cpu_usage_idle",
                        "rename": "CPU_IDLE",
                        "unit": "Percent"
                      }
                    ],
                    "metrics_collection_interval": 60
                  },
                  "disk": {
                    "measurement": [
                      {
                        "name": "used_percent",
                        "rename": "DISK_USED",
                        "unit": "Percent"
                      }
                    ],
                    "metrics_collection_interval": 60,
                    "resources": [
                      "*"
                    ]
                  },
                  "mem": {
                    "measurement": [
                      {
                        "name": "mem_used_percent",
                        "rename": "MEM_USED",
                        "unit": "Percent"
                      }
                    ],
                    "metrics_collection_interval": 60
                  }
                }
              }
            }
            CWEOF
            check_status "CloudWatch agent configuration"

            # Start CloudWatch agent
            log_info "Starting CloudWatch agent..."
            /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl \
              -a fetch-config \
              -m ec2 \
              -s \
              -c file:/opt/aws/amazon-cloudwatch-agent/etc/config.json
            check_status "CloudWatch agent start"

            # Create robust deployment script for GitHub Actions updates
            log_info "Creating deployment update script..."
            cat > /opt/bedrock-backend/deploy.sh <<'DEPLOYEOF'
            #!/bin/bash
            # Deployment Update Script - Enhanced with comprehensive logging
            set -e
            set -o pipefail

            log_info() { echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') - $1"; }
            log_error() { echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2; }
            log_success() { echo "[SUCCESS] $(date '+%Y-%m-%d %H:%M:%S') - $1"; }

            log_info "=========================================="
            log_info "Starting Rolling Deployment Update"
            log_info "=========================================="

            NEW_IMAGE=$1
            if [ -z "$NEW_IMAGE" ]; then
              log_error "No image specified! Usage: deploy.sh <image-uri>"
              exit 1
            fi
            log_info "New image: $NEW_IMAGE"

            # ECR Login
            log_info "Logging into ECR..."
            aws ecr get-login-password --region ${AWS::Region} | docker login --username AWS --password-stdin ${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com || { log_error "ECR login failed!"; exit 1; }
            log_success "ECR login successful"

            # Pull new image
            log_info "Pulling Docker image..."
            docker pull $NEW_IMAGE || { log_error "Image pull failed!"; exit 1; }
            log_success "Image pulled"

            # Stop old containers
            log_info "Stopping old containers..."
            docker stop bedrock-celery-worker bedrock-backend 2>/dev/null || true
            docker rm bedrock-celery-worker bedrock-backend 2>/dev/null || true

            # Start FastAPI
            log_info "Starting FastAPI container..."
            docker run -d \
              --name bedrock-backend \
              --restart unless-stopped \
              --network bedrock-network \
              -p 8000:8000 \
              -e SERVICE_TYPE=api \
              --env-file /opt/bedrock-backend/.env \
              --log-driver=awslogs \
              --log-opt awslogs-region=${AWS::Region} \
              --log-opt awslogs-group=/aws/ec2/bedrock-backend \
              --log-opt awslogs-stream-prefix=fastapi \
              $NEW_IMAGE || { log_error "FastAPI start failed!"; exit 1; }
            log_success "FastAPI started"

            # Start Celery
            log_info "Starting Celery worker..."
            docker run -d \
              --name bedrock-celery-worker \
              --restart unless-stopped \
              --network bedrock-network \
              -e SERVICE_TYPE=celery \
              --env-file /opt/bedrock-backend/.env \
              --log-driver=awslogs \
              --log-opt awslogs-region=${AWS::Region} \
              --log-opt awslogs-group=/aws/ec2/bedrock-backend \
              --log-opt awslogs-stream-prefix=celery \
              $NEW_IMAGE || { log_error "Celery start failed!"; exit 1; }
            log_success "Celery started"

            # Health verification
            log_info "Verifying health..."
            sleep 5
            for i in {1..30}; do
              if curl -f http://localhost:8000/health 2>/dev/null; then
                log_success "Health check passed!"
                docker image prune -f
                log_success "Deployment completed successfully!"
                exit 0
              fi
              log_info "Health check $i/30..."
              sleep 3
            done
            log_error "Health check failed!"
            docker logs bedrock-backend 2>&1 | tail -100
            exit 1
            DEPLOYEOF

            chmod +x /opt/bedrock-backend/deploy.sh
            check_status "Deployment script creation"

            log_success "=========================================="
            log_success "Bedrock Backend Setup Complete!"
            log_success "=========================================="
            log_info "Container Status:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            log_success "=========================================="

  # ==================== Auto Scaling Group ====================
  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub ${Environment}-bedrock-asg
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      MinSize: !Ref MinSize
      MaxSize: !Ref MaxSize
      DesiredCapacity: !Ref DesiredCapacity
      HealthCheckType: ELB
      HealthCheckGracePeriod: 180
      VPCZoneIdentifier: !Ref SubnetIds
      TargetGroupARNs:
        - !Ref TargetGroup
      Tags:
        - Key: Name
          Value: !Sub ${Environment}-bedrock-instance
          PropagateAtLaunch: true
        - Key: Environment
          Value: !Ref Environment
          PropagateAtLaunch: true

  # ==================== Auto Scaling Policies ====================
  ScalingPolicyCPU:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AutoScalingGroupName: !Ref AutoScalingGroup
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ASGAverageCPUUtilization
        TargetValue: 70.0

  # ==================== CloudWatch Log Group ====================
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: /aws/ec2/bedrock-backend
      RetentionInDays: 7

  # ==================== CloudWatch Alarms ====================
  HighCPUAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ${Environment}-bedrock-high-cpu
      AlarmDescription: Alert when CPU exceeds 80%
      MetricName: CPUUtilization
      Namespace: AWS/EC2
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 80
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref AutoScalingGroup

  UnhealthyHostAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ${Environment}-bedrock-unhealthy-hosts
      AlarmDescription: Alert when unhealthy host count is greater than 0
      MetricName: UnHealthyHostCount
      Namespace: AWS/ApplicationELB
      Statistic: Average
      Period: 60
      EvaluationPeriods: 2
      Threshold: 0
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: TargetGroup
          Value: !GetAtt TargetGroup.TargetGroupFullName
        - Name: LoadBalancer
          Value: !GetAtt ApplicationLoadBalancer.LoadBalancerFullName

  HighMemoryAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ${Environment}-bedrock-high-memory
      AlarmDescription: Alert when memory usage exceeds 85%
      MetricName: MEM_USED
      Namespace: BedrockBackend
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 85
      ComparisonOperator: GreaterThanThreshold

Outputs:
  LoadBalancerURL:
    Description: Application Load Balancer URL (HTTP)
    Value: !Sub http://${ApplicationLoadBalancer.DNSName}
    Export:
      Name: !Sub ${Environment}-bedrock-alb-url

  LoadBalancerDNS:
    Description: Application Load Balancer DNS Name
    Value: !GetAtt ApplicationLoadBalancer.DNSName
    Export:
      Name: !Sub ${Environment}-bedrock-alb-dns

  TargetGroupArn:
    Description: Target Group ARN
    Value: !Ref TargetGroup
    Export:
      Name: !Sub ${Environment}-bedrock-tg-arn

  SecurityGroupId:
    Description: EC2 Security Group ID
    Value: !Ref EC2SecurityGroup
    Export:
      Name: !Sub ${Environment}-bedrock-ec2-sg-id

  AutoScalingGroupName:
    Description: Auto Scaling Group Name
    Value: !Ref AutoScalingGroup
    Export:
      Name: !Sub ${Environment}-bedrock-asg-name

  LogGroupName:
    Description: CloudWatch Log Group Name
    Value: !Ref LogGroup
    Export:
      Name: !Sub ${Environment}-bedrock-log-group

  DeploymentNotes:
    Description: Important deployment information
    Value: "Container port 8000 is mapped to ALB port 80. Three containers run: FastAPI (bedrock-backend), Celery worker (bedrock-celery-worker), and Redis. CORS is configured to allow all origins. Update .env file on EC2 for configuration changes. Use deploy.sh script for updates."

  CeleryWorkerInfo:
    Description: Celery worker information
    Value: "Celery worker handles email sending asynchronously. Check logs with: docker logs bedrock-celery-worker. Redis runs on internal Docker network."
